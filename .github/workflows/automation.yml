# SPDX-FileCopyrightText: 2022  Emmanuele Bassi
# SPDX-License-Identifier: GPL-3.0-or-later

name: Automation

on:
  issues:
    types: [opened, edited, labeled, unlabeled]
  pull_request:
    types: [opened, edited, labeled, unlabeled, ready_for_review]
  schedule:
    # Run daily at 9:00 AM UTC
    - cron: '0 9 * * *'
  workflow_dispatch:

jobs:
  label-issues:
    name: Auto-label Issues
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && github.event.action == 'opened'
    permissions:
      issues: write
    steps:
    - name: Auto-label based on title and body
      uses: actions/github-script@v7
      with:
        script: |
          const issue = context.payload.issue;
          const title = issue.title.toLowerCase();
          const body = issue.body ? issue.body.toLowerCase() : '';
          const labels = [];
          
          // Platform-specific labels
          if (title.includes('windows') || body.includes('windows') || body.includes('msys2')) {
            labels.push('platform: windows');
          }
          if (title.includes('linux') || body.includes('linux') || body.includes('flatpak')) {
            labels.push('platform: linux');
          }
          if (title.includes('freebsd') || body.includes('freebsd')) {
            labels.push('platform: freebsd');
          }
          
          // Component labels
          if (title.includes('audio') || title.includes('gstreamer') || title.includes('sound') || body.includes('playback')) {
            labels.push('component: audio');
          }
          if (title.includes('ui') || title.includes('interface') || title.includes('gtk') || title.includes('libadwaita')) {
            labels.push('component: ui');
          }
          if (title.includes('build') || title.includes('compile') || title.includes('meson') || title.includes('cargo')) {
            labels.push('component: build');
          }
          if (title.includes('install') || title.includes('package') || title.includes('distribution')) {
            labels.push('component: packaging');
          }
          
          // Issue type labels
          if (title.includes('crash') || title.includes('segfault') || title.includes('panic')) {
            labels.push('type: crash');
            labels.push('priority: high');
          } else if (title.includes('feature') || title.includes('enhancement') || title.includes('request')) {
            labels.push('type: enhancement');
          } else if (title.includes('bug') || title.includes('error') || title.includes('issue') || title.includes('problem')) {
            labels.push('type: bug');
          }
          
          // Priority labels based on severity keywords
          if (title.includes('critical') || title.includes('urgent') || body.includes('data loss')) {
            labels.push('priority: critical');
          } else if (title.includes('regression') || body.includes('worked before')) {
            labels.push('priority: high');
          }
          
          // Quality labels
          if (body.includes('steps to reproduce') && body.includes('expected') && body.includes('actual')) {
            labels.push('quality: good-report');
          }
          
          // Add labels if any were determined
          if (labels.length > 0) {
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              labels: labels
            });
            
            console.log(`Added labels: ${labels.join(', ')}`);
          }

  welcome-first-time:
    name: Welcome First-time Contributors
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.action == 'opened'
    permissions:
      pull-requests: write
    steps:
    - name: Check if first-time contributor
      uses: actions/github-script@v7
      with:
        script: |
          const pr = context.payload.pull_request;
          const author = pr.user.login;
          
          // Check if this is the user's first contribution
          const { data: prs } = await github.rest.pulls.list({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'all',
            per_page: 100
          });
          
          const authorPrs = prs.filter(p => p.user.login === author);
          
          if (authorPrs.length === 1) { // This is their first PR
            const welcomeMessage = `
          👋 Welcome to Amberol, @${author}! Thank you for your first contribution!
          
          A few things to keep in mind:
          - Make sure your PR follows our [contribution guidelines](CONTRIBUTING.md)
          - All tests should pass before the PR can be merged
          - Feel free to ask questions if you need help!
          
          Our maintainers will review your changes soon. Thanks for making Amberol better! 🎵
            `;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              body: welcomeMessage
            });
            
            // Add first-time contributor label
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              labels: ['good first contribution']
            });
          }

  auto-close-stale:
    name: Close Stale Issues
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
    permissions:
      issues: write
    steps:
    - name: Close stale issues
      uses: actions/github-script@v7
      with:
        script: |
          const staleAfterDays = 60;
          const warningAfterDays = 45;
          const staleDate = new Date();
          staleDate.setDate(staleDate.getDate() - staleAfterDays);
          const warningDate = new Date();
          warningDate.setDate(warningDate.getDate() - warningAfterDays);
          
          // Get all open issues
          const { data: issues } = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open',
            per_page: 100
          });
          
          for (const issue of issues) {
            if (issue.pull_request) continue; // Skip PRs
            
            const lastUpdate = new Date(issue.updated_at);
            const labels = issue.labels.map(label => label.name);
            
            // Skip issues with certain labels
            if (labels.includes('pinned') || 
                labels.includes('priority: critical') || 
                labels.includes('priority: high') ||
                labels.includes('long-term')) {
              continue;
            }
            
            if (lastUpdate < staleDate) {
              // Close stale issues
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                state: 'closed',
                state_reason: 'not_planned'
              });
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `This issue has been automatically closed due to inactivity. If this issue is still relevant, please reopen it with additional information.`
              });
              
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: ['auto-closed']
              });
              
              console.log(`Closed stale issue #${issue.number}: ${issue.title}`);
              
            } else if (lastUpdate < warningDate && !labels.includes('stale-warning')) {
              // Warn about upcoming closure
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `⚠️ This issue has been inactive for ${warningAfterDays} days and will be automatically closed in ${staleAfterDays - warningAfterDays} days if there is no further activity. Please comment if this issue is still relevant.`
              });
              
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: ['stale-warning']
              });
              
              console.log(`Added stale warning to issue #${issue.number}: ${issue.title}`);
            }
          }

  pr-status-check:
    name: PR Status Check
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    permissions:
      pull-requests: write
      checks: write
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Check PR requirements
      uses: actions/github-script@v7
      with:
        script: |
          const pr = context.payload.pull_request;
          const files = await github.rest.pulls.listFiles({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_request_number: pr.number
          });
          
          const changedFiles = files.data.map(file => file.filename);
          const checks = [];
          
          // Check if CHANGES.md needs to be updated
          const hasSourceChanges = changedFiles.some(file => 
            file.startsWith('src/') || 
            file.includes('Cargo.toml') || 
            file.includes('meson.build')
          );
          
          const hasChangesUpdate = changedFiles.includes('CHANGES.md');
          
          if (hasSourceChanges && !hasChangesUpdate) {
            checks.push({
              name: 'changelog-update',
              status: 'warning',
              message: 'Consider updating CHANGES.md for user-facing changes'
            });
          }
          
          // Check for Windows-specific changes
          const hasWindowsChanges = changedFiles.some(file =>
            file.includes('windows') ||
            file.includes('.ps1') ||
            file.includes('.bat') ||
            file.includes('msys2')
          );
          
          if (hasWindowsChanges) {
            checks.push({
              name: 'windows-testing',
              status: 'pending',
              message: 'Windows-specific changes detected - ensure testing on Windows'
            });
          }
          
          // Check for large PRs
          if (files.data.length > 20) {
            checks.push({
              name: 'large-pr',
              status: 'warning',
              message: 'Large PR detected - consider splitting into smaller changes'
            });
          }
          
          // Post status checks as comments
          if (checks.length > 0) {
            let comment = '## PR Status Checks\n\n';
            
            for (const check of checks) {
              const emoji = check.status === 'warning' ? '⚠️' : check.status === 'error' ? '❌' : '⏳';
              comment += `${emoji} **${check.name}**: ${check.message}\n\n`;
            }
            
            // Check if we already posted a status comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('PR Status Checks')
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body: comment
              });
            }
          }

  auto-assign-reviewers:
    name: Auto-assign Reviewers
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && (github.event.action == 'opened' || github.event.action == 'ready_for_review')
    permissions:
      pull-requests: write
    steps:
    - name: Assign reviewers based on changed files
      uses: actions/github-script@v7
      with:
        script: |
          const pr = context.payload.pull_request;
          
          // Skip if PR is from a fork (external contributor)
          if (pr.head.repo.full_name !== pr.base.repo.full_name) {
            console.log('External PR - skipping auto-assignment');
            return;
          }
          
          const files = await github.rest.pulls.listFiles({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_request_number: pr.number
          });
          
          const changedFiles = files.data.map(file => file.filename);
          const reviewers = new Set();
          
          // Define code owners based on file patterns
          const codeOwners = {
            'src/windows.rs': ['@windows-maintainer'],
            'build_windows.ps1': ['@windows-maintainer'],
            '*.yml': ['@ci-maintainer'],
            'src/audio/': ['@audio-maintainer'],
            'data/': ['@ui-maintainer'],
            'po/': ['@l10n-maintainer']
          };
          
          // Add reviewers based on changed files
          for (const file of changedFiles) {
            for (const [pattern, owners] of Object.entries(codeOwners)) {
              if (file.includes(pattern.replace('*', '')) || file.startsWith(pattern.replace('*', ''))) {
                owners.forEach(owner => reviewers.add(owner.substring(1))); // Remove @
              }
            }
          }
          
          // Convert to array and filter out the PR author
          const reviewerList = Array.from(reviewers).filter(reviewer => reviewer !== pr.user.login);
          
          if (reviewerList.length > 0) {
            await github.rest.pulls.requestReviewers({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_request_number: pr.number,
              reviewers: reviewerList.slice(0, 2) // Limit to 2 reviewers
            });
            
            console.log(`Assigned reviewers: ${reviewerList.join(', ')}`);
          }

  project-management:
    name: Project Management
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' || github.event_name == 'pull_request'
    permissions:
      issues: write
      pull-requests: write
    steps:
    - name: Add to project board
      uses: actions/github-script@v7
      with:
        script: |
          const item = context.payload.issue || context.payload.pull_request;
          const labels = item.labels ? item.labels.map(label => label.name) : [];
          
          // Add high priority items to urgent column
          if (labels.includes('priority: critical') || labels.includes('priority: high')) {
            console.log(`High priority item detected: ${item.title}`);
            // Here you would add logic to add to project boards
            // This is a placeholder for project board integration
          }
          
          // Add feature requests to backlog
          if (labels.includes('type: enhancement')) {
            console.log(`Feature request detected: ${item.title}`);
            // Add to feature backlog
          }